#set text(font: "Malgun Gothic", size: 11pt)
#set page(numbering: "1", margin: (left: 20mm, right: 20mm, top: 20mm, bottom: 20mm))
#set par(justify: true)
#set heading(numbering: "1.")

#show math.equation: set text(weight: "regular")

// 핵심 개념 설명 상자 스타일
#let key-concept(title, body) = block(
  fill: rgb("#e8f4f8"),
  inset: 10pt,
  radius: 5pt,
  stroke: 2pt + rgb("#0066cc"),
  width: 100%,
  [
    *#title* \
    #body
  ]
)

// 쉽게 설명하기 상자
#let plain-english(body) = block(
  fill: rgb("#f0f8e8"),
  inset: 10pt,
  radius: 5pt,
  stroke: 2pt + rgb("#228b22"),
  width: 100%,
  [
    *쉽게 설명하기:* \
    #body
  ]
)

// 기술적 참고 상자
#let tech-note(body) = block(
  fill: rgb("#fff8e8"),
  inset: 10pt,
  radius: 5pt,
  stroke: 2pt + rgb("#b8860b"),
  width: 100%,
  [
    *기술적 참고:* \
    #body
  ]
)

= 아키텍처 개요

== 프로젝트 요약

SM_2D는 CUDA 가속 GPU 컴퓨팅을 사용하는 양성자 치료 선량 계산을 위한 고성능 2D 결정론적 수송 솔버입니다. 이 프로젝트는 블록-희소 위상 공간 표현을 사용하는 계층적 S-행렬 솔버를 구현합니다.

#plain-english[
  *인체를 통과하는 수천 개의 보이지 않는 미세한 입자(양성자)가 정확히 어디로 갈지 예측하려고 한다고 상상해보세요.* SM_2D는 문제를 수백만 개의 작은 조각으로 나누고, 그래픽 카드(GPU)에서 각 조각을 동시에 해결하며, 모든 에너지가 어디에 있는지 추적하는 초강력 계산기와 같습니다. 이는 의사들이 암 치료를 더 정확하게 계획하는 데 도움이 됩니다.
]

=== 핵심 통계

#figure(
  table(
    columns: (auto, 1fr),
    inset: 8pt,
    align: left,
    table.header([*메트릭*], [*값*]),
    [전체 파일], [30개 이상의 C++ 소스 파일],
    [CUDA 커널], [6개 주요 커널(K1-K6)],
    [코드 라인 수], [~15,000 라인],
    [시뮬레이션당 메모리], [~3 GB GPU 메모리],
    [그리드 크기], [최대 200 × 640 셀],
  ),
  caption: [시스템 메트릭],
)

== C++ 개념 이해하기

#key-concept(
  [C++란 무엇인가요?],
  [
    C++는 프로그래머에게 컴퓨터 하드웨어에 대한 직접적인 제어권을 주는 고성능 프로그래밍 언어입니다. 자동차 대신 수동 변속기 자동차를 운전하는 것과 같습니다. 더 많은 제어권을 가지고 더 빨리 갈 수 있지만, 무엇을 하는지 알아야 합니다.

    *SM_2D에 C++를 사용하는 이유는 무엇인가요?*
    - *속도*: C++는 기계어로 직접 컴파일되어 가능한 한 빠르게 실행됩니다
    - *제어*: 메모리 및 하드웨어 기능에 대한 직접적인 액세스
    - *GPU 통합*: 병렬 컴퓨팅을 위한 NVIDIA의 CUDA와 원활한 통합
  ]
)

=== 클래스와 객체

#plain-english[
  *클래스*는 집의 청사진과 같습니다. 집이 어떻게 생겼고 무엇을 할 수 있는지 정의하지만, 그 자체로는 집이 아닙니다. *객체*는 그 청사진에서 지어진 실제 집입니다.

  SM_2D에서:
  - *클래스*: "Particle" - 입자가 무엇인지 정의(위치, 에너지, 방향)
  - *객체*: 특정 위치에서 특정 에너지를 가진 특정 양성자
]

=== 포인터와 메모리

#tech-note(
  [*포인터*는 다른 변수의 메모리 주소를 저장하는 변수입니다. 전달 주소와 같습니다 - 우편물 자체를 포함하지 않고 우편물이 어디에 있는지 알려줍니다. C++에서 포인터는 CPU 메모리(RAM)와 GPU 메모리(VRAM) 사이에서 데이터를 전송해야 하므로 GPU 컴퓨팅에 매우 중요합니다. 포인터를 사용하면 배열을 복사하지 않고 효율적으로 전달할 수 있습니다.]
)

=== 템플릿

#plain-english[
  *템플릿*은 쿠키 커터와 같습니다 - 같은 커터를 다른 종류의 반죽에 사용할 수 있습니다. 정수, 부동 소수점, 이중 정수에 대한 별도의 함수를 작성하는 대신, 모든 유형에 작동하는 하나의 템플릿을 작성합니다.

  SM_2D에서 템플릿은 모든 것을 다시 작성하지 않고도 물리 코드가 다른 정밀도 수준으로 작동하게 합니다.
]

=== 헤더 파일(.hpp)과 소스 파일(.cpp)

#key-concept(
  [헤더와 소스],
  [
    *헤더 파일(.hpp)*: 책의 목차와 색인과 같습니다. 함수와 클래스가 존재한다는 것을 선언하지만 실제 코드는 포함하지 않습니다.

    *소스 파일(.cpp)*: 책의 실제 장과 같습니다. 작동을 만드는 실제 코드인 구현을 포함합니다.

    *왜 분리하는가?*
    - 더 빠른 컴파일(변경된 부분만 재컴파일)
    - 더 깨끗한 구성(인터페이스 vs 구현)
    - 공유 선언(여러 파일이 같은 헤더를 포함할 수 있음)
  ]
)

== 시스템 아키텍처

=== 아키텍처 계층

시스템은 6개의 개별 계층으로 구성됩니다:

#figure(
  image("diagrams/architecture_layers_kr.svg", width: 80%),
  caption: [입력에서 출력까지의 데이터 흐름을 보여주는 시스템 아키텍처 계층],
)

==== 입력 계층

*목적*: 모든 구성 및 물리 데이터 로드 및 준비

#plain-english[
  요리하기 전에 모든 재료를 모으는 것과 같습니다. 이 계층은 레시피(sim.ini)를 읽고, NIST에서 물리 데이터를 가져오며(전문 요리 데이터베이스처럼), 명령줄의 특별 지시사항을 확인합니다.
]

*구성요소*:
- `sim.ini`: 시뮬레이션 매개변수가 있는 구성 파일
- NIST PSTAR 물리 데이터: 물질에서 양성자의 상호작용에 대한 실제 측정값
- 명령줄 매개변수: 사용자 재정의 및 옵션

#key-concept(
  [NIST PSTAR 데이터베이스],
  [
    미국 표준 기술 연구소(NIST)는 PSTAR 데이터베이스를 유지 관리하며, 이 데이터베이스에는 다양한 물질을 통과할 때 양성자가 에너지를 잃는 방법에 대한 정밀한 측정값이 포함되어 있습니다. 수십 년의 실험에서 만들어진 거대한 조회 테이블로 생각하세요. SM_2D는 처음부터 모든 것을 계산하는 대신 이 데이터를 사용합니다.
  ]
)

==== 코어 계층

*목적*: 입자 정보를 구성하는 기본 데이터 구조

*구성요소*:

1. *에너지/각도 그리드*

   #plain-english[
     행이 다른 입자 에너지이고 열이 다른 방향인 스프레드시트를 상상해보세요. 이 그리드를 사용하면 모든 에너지에서 모든 방향으로 이동하는 입자의 속성을 빠르게 조회할 수 있습니다.
   ]

   *에너지 그리드*: 0.1에서 250 MeV까지 256개 빈(로그 간격)
   *각도 그리드*: -90°에서 +90°까지 512개 빈

   #figure(
     table(
       columns: (1fr, 1fr),
       inset: 8pt,
       align: left,
       table.header([*그리드*], [*구성*]),
       [에너지 그리드], [0.1 MeV → 250 MeV, 256개 빈 (로그 간격)],
       [각도 그리드], [-90° → +90°, 512개 빈 (선형 간격)],
     ),
     caption: [에너지 및 각도 그리드 구성],
   )

2. *블록 인코딩(24비트)*

   #key-concept(
     [블록 인코딩: 메모리 압축],
     [
       "에너지 빈 1234 및 각도 빈 5678"을 두 개의 별도 숫자(8바이트)로 저장하는 대신 단일 24비트 숫자(3바이트)로 패킹합니다. 이렇게 하면 62.5%의 메모리를 절약합니다!

       "12시간 34분" 대신 "12:34"를 쓰는 것과 같습니다. 같은 정보, 더 적은 공간.
     ]
   )

   #figure(
     table(
       columns: (1fr, 1fr, 1fr),
       inset: 8pt,
       align: center,
       table.header([*필드*], [*비트*], [*범위*]),
       [b_E (에너지 빈)], [Bits 12-23], [0-4095],
       [b_theta (각도 빈)], [Bits 0-11], [0-4095],
       table.footer(
         [결합], [24비트 Block ID], [
           예제: 빈 (1500, 800) → 6,080,832\
           메모리: 3바이트 (8바이트 대신)
         ],
       ),
     ),
     caption: [24비트 블록 인코딩 방식],
   )

3. *위상 공간 저장소(계층적)*

   #plain-english[
     "위상 공간"은 입자의 상태를 설명하는 데 필요한 모든 정보에 대한 물리학 용어일 뿐입니다. 여기에는 위치, 방향 및 에너지가 포함됩니다. 모든 입자를 개별적으로 저장하는 대신 에너지와 방향을 기준으로 입자를 "블록"으로 그룹화한 다음 실제로 입자가 있는 블록만 저장합니다.
   ]

   #tech-note(
     [계층적 구조는 다음을 의미합니다: (1) 전역 위상 공간은 셀로 나뉩니다, (2) 각 셀은 에너지/각도를 기준으로 블록으로 나뉩니다, (3) 각 블록에는 하위 셀 위치에 대한 512개 로컬 빈이 포함됩니다, (4) 활성 블록에만 메모리가 할당됩니다(희소 저장). 이렇게 하면 메모리 사용량이 70-90% 감소할 수 있습니다.]
   )

4. *버킷 방출(셀 간)*

   #key-concept(
     [버킷: 입자 전송 시스템],
    [
      입자가 한 셀에서 다른 셀로 교차할 때 즉시 처리하지 않습니다. 대신 각 대상 셀에 대한 "버킷"에 수집합니다. 우편 분류실과 같습니다 - 다른 우편번호로 가는 편지는 다른 버킷으로 분류된 다음 각 버킷이 한 번의 여행으로 배달됩니다.

      이것은 각 편지를 개별적으로 배달하는 것보다 훨씬 효율적입니다!
    ]
  )

==== 물리 계층

*목적*: 물질과 양성자의 상호작용 모델링

*구성요소*:

1. *Highland 다중 쿨롬 산란(MCS)*

   #plain-english[
     양성자가 물질을 통과할 때 직선으로 이동하지 않습니다. 원자핵에 의해 편향되어 핀볼처럼 튑니다. 이것을 "다중 쿨롬 산란"(MCS)이라고 합니다.

     *비유*: 붐비는 방을 걷는 것을 상상해보세요. 똑바로 걸으려고 해도 사람들과 부딪히고 옆으로 밀립니다. 이것이 조직에서 양성자에게 일어나는 일입니다.
   ]

   #key-concept(
     [Highland 공식],
     [
       Highland 공식은 에너지와 통과하는 물질을 기준으로 양성자가 얼마나 산란하는지 예측합니다. 더 높은 에너지 = 더 적은 산란. 더 밀도가 높은 물질 = 더 많은 산란.

       $ sigma_"theta" = (13.6 " MeV")/(beta c p) sqrt(s/X_0) [1 + 0.038 ln(s/X_0)] $

       무섭게 보이더라도 걱정하지 마세요. 이것은 "에너지와 물질을 기준으로 산란 각도를 계산"한다는 의미입니다.
     ]
   )

2. *Vavilov 에너지 분산*

   #plain-english[
     양성자는 완벽하게 일정한 비율로 에너지를 잃지 않습니다. 때로는 조금 잃고, 때로는 많이 잃습니다. 이 변화를 "분산"이라고 합니다. 같은 경로에서도 자동차의 연비가 여행마다 다르는 것과 같습니다.

     *중요한 이유*: 분산을 무시하면 예측이 너무 매끄러워져 실제 측정값과 일치하지 않습니다.
   ]

   #tech-note(
     [Vavilov 분포는 더 간단한 가우시안(정규) 분포보다 더 정확한 모델입니다. 때로는 양성자가 단일 충돌에서 많은 에너지를 잃는("델타 선") 사실을 고려하여 분포에 긴 꼬리를 만듭니다.]
   )

3. *핵 감쇠*

   #key-concept(
     [핵 반응: 입자 사라짐],
     [
       때로는 양성자가 원자핵과 정면으로 충돌하여 빔에서 완전히 흡수되거나 산란됩니다. 이것이 "핵 감쇠"입니다. 빌리어드 공이 다른 공을 너무 세게 때려서 테이블에서 튀어 나가는 것과 같습니다.

       SM_2D에서는 이것을 "손실된 가중치"로 추적합니다 - 입자의 선량 기여도는 사라지지만 에너지는 이를 고려하므로 보존됩니다.
     ]
   )

4. *R 기반 단계 제어*

   #plain-english[
     양성자가 속성을 다시 계산하기 전에 얼마나 멀리 이동해야 할까요? 그것이 "단계 크기"입니다. 양성자의 사거리(R) - 멈추기 전에 이동할 수 있는 총 거리 - 를 사용하여 단계 크기를 결정합니다.

     *규칙*: 단계 크기 = min(남은 사거리의 2%, 셀 경계까지의 거리)

       이것은 입자가 거의 멈출 때(브래그 피크 근처) 더 작은 단계를 밟아 더 나은 정확도를 얻음을 의미합니다.
   ]

5. *Fermi-Eyges 횡방향 확산*

   #tech-note(
     [Fermi-Eyges 이론은 양성자 빔이 조직을 통과할 때 옆으로 퍼지는 방법을 계산합니다. 여러 작은 산란 사건이 가우시안(종형 곡선) 분포로 합쳐진다는 아이디어를 기반으로 합니다. 이것은 "펨브라" - 선량이 점차 떨어지는 빔의 흐린 가장자리 - 예측에 매우 중요합니다.]
   )

==== CUDA 파이프라인

*목적*: GPU에서 병렬로 물리 계산 실행

#plain-english[
  CPU 컴퓨팅이 한 사람이 수학 문제를 하나씩 푸는 것과 같다면, GPU 컴퓨팅은 10,000명이 모두 동시에 수학 문제를 푸는 것과 같습니다. CUDA 파이프라인은 이 병렬 워크포스를 구성하는 "조립 라인"입니다.
]

#figure(
  table(
    columns: (auto, 3fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*커널*], [*기능*]),
    [K1: ActiveMask], [활성 셀 식별 - 입자가 있는 셀만 처리, 빈 셀 건너뛰기],
    [K2: 거친 수송], [고에너지 입자 빠른 수송 - 큰 단계, 간단한 물리 (브래그 피크에서 멀리)],
    [K3: 정밀 수송], [저에너지 입자 정확한 수송 - 작은 단계, 전체 물리 (브래그 피크 근처)],
    [K4: 버킷 전송], [셀 간 입자 이동 - 셀 경계 교차 입자 수집],
    [K5: 보존 감사], [물리 보존 법칙 검증 - 가중치 및 에너지 보존 확인],
    [K6: 버퍼 교환], [다음 단계 준비 - 입출력 버퍼 교환],
  ),
  caption: [CUDA 커널 파이프라인 (병렬 실행 흐름)],
)

#key-concept(
  [왜 커널인가?],
  [
    *커널*은 GPU에서 실행되는 함수입니다. 한 번 실행되는 일반 함수와 달리 커널은 데이터 조각마다数千번 병렬로 실행됩니다.

    *비유*: 일반 함수는 야채를 자르는 한 명의 요사와 같습니다. GPU 커널은 각자 하나의 야채를 자르는 10,000명의 요사와 같습니다.
  ]
)

==== 출력 계층

*목적*: 결과 수집 및 보고서 생성

#plain-english[
  모든 입자 수송이 완료된 후 유용한 형태로 결과를 제시해야 합니다. 이 계층은 선량 맵, 깊이-선량 곡선을 생성하고 시뮬레이션이 에너지를 제대로 보존했는지 확인합니다.
]

*구성요소*:
- *2D 선량 분포*: 각 지점에서의 방사선 선량을 보여주는 색상 맵
- *깊이-선량 곡선*: 깊이에 대한 선량 플롯(브래그 피크 표시)
- *보존 보고서*: 에너지 입력 = 에너지 출력 확인

== 모듈 의존성 그래프

=== 기초 계층

#figure(
  table(
    columns: (auto, 1fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*모듈*], [*기능*]),
    [ NIST PSTAR 데이터 로드], [사거리-에너지 조회 테이블 생성],
    [ 빠른 보간 제공], [로그 간격 에너지 빈 (저에너지에서 더 높은 해상도)],
    [ `sim.ini` 읽기], [모든 모듈이 액세스하는 `Config` 객체 생성],
    [ 매개변수 일관성 보장], [매직 넘버 없음, 혼란 없음],
    [ 비행 기록기 역할], [DEBUG, INFO, WARNING, ERROR 수준],
    [ 문제 발생 시 로그 확인], [시뮬레이션 중 발생하는 모든 것 기록],
  ),
  caption: [기초 계층 모듈],
)

=== 데이터 구조 계층

#figure(
  table(
    columns: (auto, 1fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*구조*], [*설명*], [*세부사항*]),
    [그리드], [입자 속성 좌표계], [에너지: 0.1-250 MeV (256 빈), 각도: -90°~+90° (512 빈)],
    [블록 인코딩], [24비트 ID 압축], [b_E (12비트) + b_theta (12비트), 62.5% 메모리 절약],
    [로컬 빈], [4D 하위 셀 분할], [4×4(x,z) × 8×4(θ,E) = 512 빈/블록],
    [Psi 저장소], [계층적 희소 메모리], [활성 블록만 저장, 70-90% 메모리 감소],
    [버킷], [셀 간 입자 전송], [해시 맵: O(1) 조회, 경합 조건 방지],
  ),
  caption: [데이터 구조 모듈],
)

=== 물리 모듈 계층

#figure(
  table(
    columns: (auto, 2fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*모듈*], [*기능*], [file]),
    [Highland MCS], [다중 쿨롬 산란 - 핵에서 튀는 입자, 산란 각도 계산], [`highland.hpp`],
    [에너지 분산], [Vavilov 분산 - 에너지 변동, 무작위성 모델링], [`energy_straggling.hpp`],
    [핵 감쇠], [핵 반응 - 흡수 및 손실 추적, 에너지 보존], [`nuclear.hpp`],
    [단계 제어], [R 기반 단계 크기 - 적응형 조정 (2% 규칙)], [`step_control.hpp`],
    [Fermi-Eyges], [횡방향 확산 - 펨브라 예측, 옆으로 퍼지는 빔], [`fermi_eyges.hpp`],
  ),
  caption: [물리 모듈 의존성],
)

=== CUDA 커널 계층

#figure(
  table(
    columns: (auto, 2fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([커널], [기능], [file]),
    [K1: ActiveMask], [활성 셀 식별 - 빈 셀 건너뛰기로 시간 절약], [k1_activemask.cu],
    [K2: 거침 수송], [고에너지 빠른 수송 - 브래그 피크에서 먼 입자], [k2_coarsetransport.cu],
    [K3: 정밀 수송], [주요 물리 - 5가지 과정 적용, 계산적으로 가장 비쌈], [k3_finetransport.cu],
    [K4: 버킷 전송], [셀 경계 교차 입자 수집 및 이동], [`k4_transfer.cu`],
    [K5: 보존 감사], [물리 보존 법칙 검증 - 수치 오류 감지], [`k5_audit.cu`],
    [K6: 버퍼 교환], [입출력 교환 - 다음 단계 준비], [`k6_swap.cu`],
  ),
  caption: [순차 실행을 보여주는 CUDA 커널 파이프라인],
)

#plain-english[
  *거친 수송 vs 정밀 수송*: 거친은 빠르고 덜 정확하며 고에너지에 적합합니다. 정밀은 느리지만 더 정확하며 저에너지(브래그 피크 근처)에 필수적입니다. 둘 다 사용하면 허용 가능한 곳에서 속도를 얻고 필요한 곳에서 정확도를 얻을 수 있습니다.
]

=== 소스 계층

#figure(
  table(
    columns: (auto, 2fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*소스*], [*특징*], [*용도*]),
    [연필 소스], [이상적 빔 - 델타 함수, 너비 0], [테스트 및 검증용, 완벽하게 예측 가능],
    [가우시안 소스], [현실적 빔 - 시그마 너비, 유한 폭], [임상 정확도, 실제 빔 프로필 모델링],
  ),
  caption: [소스 모듈 옵션],
)

=== 경계 계층

#figure(
  table(
    columns: (auto, 2fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*모듈*], [*기능*], [file]),
    [경계 조건], [흡수/반사/주기적 조건 처리], [`boundaries.cpp`],
    [손실 추적], [경계/차단/핵 손실 추적], [`loss_tracking.cpp`],
  ),
  caption: [경계 처리 모듈],
)

#key-concept(
  [왜 손실을 추적하는가?],
  [
    입자는 다양한 이유로 시뮬레이션을 떠날 수 있습니다:
    - *경계 손실*: 시뮬레이션 볼륨을 떠남
    - *차단 손실*: 에너지가 임계값 미만임
    - *핵 손실*: 핵에 의해 흡수됨

    이것들을 별도로 추적하면 물리를 검증하고 근사치가 어디서 실패하는지 이해하는 데 도움이 됩니다.
  ]
)

=== 감사 계층

#figure(
  table(
    columns: (auto, 2fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*모듈*], [*기능*], [file]),
    [보존 검사], [에너지/가중치/운동량 보존 확인], [`conservation.cpp`],
    [전체 예산], [누적 양 추적 - 합계, 시간, 드리프트 감지], [`global_budget.cpp`],
    [보고], [CSV/콘솔/파일 출력 생성], [`reporting.cpp`],
  ),
  caption: [감사 모듈 구성요소],
)

=== 검증 계층

#plain-english[
  임상 사용을 위해 시뮬레이션을 신뢰하기 전에 검증해야 합니다 - 올바른 결과를 생성한다는 것을 증명합니다. 검증 계층은 알려진 해석 해결책 및 실험 데이터와 결과를 비교합니다.
]

*검증 테스트*:
- *브래그 피크 검증*: 해석 예측과 깊이-선량 곡선 비교
- *횡방향 확산 검증*: Fermi-Eyges 이론과 펨브라 비교
- *결정론성 테스트*: 두 번 실행하여 동일한 결과 확인

== 메모리 레이아웃

=== GPU 메모리 분해

#figure(
  table(
    columns: (auto, auto, auto),
    inset: 8pt,
    align: left,
    table.header([*버퍼*], [*크기*], [*유형*]),
    [PsiC_in/out], [각각 1.1 GB], [float32],
    [EdepC], [0.5 GB], [float64],
    [AbsorbedWeight_cutoff], [0.25 GB], [float32],
    [AbsorbedWeight_nuclear], [0.25 GB], [float32],
    [AbsorbedEnergy_nuclear], [0.25 GB], [float64],
    [BoundaryLoss], [0.1 GB], [float32],
    [ActiveMask/List], [0.5 GB], [uint8/uint32],
    table.footer([*총계*], [*~4.3 GB*], []),
  ),
  caption: [GPU 메모리 레이아웃],
)

#figure(
  image("diagrams/memory_layout_kr.svg", width: 90%),
  caption: [GPU 메모리 할당의 시각적 표현],
)

#plain-english[
  GPU 메모리를 거대한 창고로 생각하세요. "PsiC_in"과 "PsiC_out"은 모든 입자 정보를 보관하는 주요 저장 영역입니다. 하나를 읽는 동안 다른 하나에 쓸 수 있도록 두 개가 필요합니다(두 개의 화이트보드를 가지는 것과 같음).

  다른 배열은 전용 저장실과 같습니다 - 에너지 퇴적 추적, 손실 추적 등을 위한 것입니다.
]

=== 왜 다른 데이터 유형인가?

#key-concept(
  [데이터 유형 선택],
  [
    *float32*: 32비트 부동 소수점(6-7십진 자릿수)
    - 위상 공간(PsiC)에 사용
    - 더 작은 메모리, 더 빠른 계산
    - 수송에 충분한 정밀도

    *float64*: 64비트 부동 소수점(15-16십진 자릿수)
    - 에너지 퇴적(EdepC)에 사용
    - 합산을 위한 더 높은 정밀도
    - 합계의 반올림 오류 방지

    *uint8/uint32*: 부호 없는 정수
    - 마스크 및 인덱스에 사용
    - 음수 값이 필요하지 않음
    - 컴팩트한 저장소
  ]
)

== 위상 공간 표현

=== 4차원 위상 공간

#plain-english[
  "위상 공간"은 입자의 상태를 설명하는 데 필요한 모든 정보에 대한 물리학 용어일 뿐입니다. 우리의 경우 4차원입니다:
  1. x 위치(횡방향)
  2. z 위치(깊이)
  3. 방향 theta(각도)
  4. 에너지 E
]

#figure(
  image("diagrams/phase_space_kr.svg", width: 80%),
  caption: [4D 위상 공간 시각화],
)

=== 블록 인코딩 상세

#figure(
  table(
    columns: (1fr, 1fr, 1fr),
    inset: 8pt,
    align: center,
    stroke: 1pt,
    table.header([*필드*], [*값*], [*설명*]),
    [에너지 빈], [1500], [256개 빈 중, 12비트 이진: 0101 1101 1100],
    [각도 빈], [800], [512개 빈 중, 12비트 이진: 0011 0010 0000],
    [이진 표현], [0101 1101 1100 0011 0010 0000], [24비트],
    [10진수], [6,080,832], [단일 숫자로 패킹],
    [메모리], [3바이트], [두 개의 int에 8바이트 대신, 62.5% 절약],
  ),
  caption: [블록 인코딩 예제 상세],
)

=== 로컬 인덱스 계산

#plain-english[
  각 블록 내에 512개 로컬 빈이 있습니다. 입자가 어느 빈에 있는지 식별하기 위해 4개 좌표에서 계산된 16비트 로컬 인덱스를 사용합니다.
]

#figure(
  table(
    columns: (auto, 2fr, 1fr),
    inset: 8pt,
    align: left,
    stroke: 1pt,
    table.header([*좌표*], [*범위*], [*비트*]),
    [theta_local], [8개 값 (0-7)], [3비트],
    [E_local], [4개 값 (0-3)], [2비트],
    [x_sub], [4개 값 (0-3)], [2비트],
    [z_sub], [4개 값 (0-3)], [2비트],
    table.footer([*계산*], [idx = theta + 8×(E + 4×(x + 4×z))], [총 9비트]),
  ),
  caption: [로컬 인덱스 인코딩],
)

#plain-english[
  *예제*: z_sub=1, x_sub=2, E_local=3, theta_local=5 \
  → idx = 5 + 8×(3 + 4×(2 + 4×1)) = 221
]

#key-concept(
  [왜 하위 셀인가?],
  [
    하위 셀은 각 셀 내에서 공간 해상도를 제공합니다. 입자가 셀 전체에 균일하게 분포되어 있다고 가정하는 대신 4×4 하위 셀 해상도로 위치를 추적합니다. 이것은 선량 구배가 가파른 브래그 피크 근처에서 정확도를 향상시킵니다.

    저해상도 카메라 대신 고해상도 카메라를 가지는 것과 같습니다 - 더 세밀한 세부사항을 볼 수 있습니다.
  ]
)

== 단계별 물리 파이프라인

=== 단계 시퀀스

#plain-english[
  각 수송 단계에 대해 일련의 물리 작업을 모든 입자에 적용합니다. 이것이 "물리 파이프라인"입니다 - 입자 속성을 업데이트하는 계산 순서입니다.
]

#figure(
  table(
    columns: (auto, 4fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*단계*], [*작업*], [*공식*]),
    [1. 단계 제어], [얼마나 멀리 갈지 결정], [ds = min(2%×R, dx, dz)],
    [2. 에너지 손실], [이동하면서 에너지 손실], [E_new = E_old - (dE/ds)×ds],
    [3. 분산], [무작위 에너지 변동 추가], [ΔE ~ Vavilov(κ)],
    [4. MCS], [입자 방향 변경], [θ_new = θ_old + σ_θ×N(0,1)],
    [5. 핵 감쇠], [일부 입자 흡수], [W_new = W_old×exp(-σ×ds)],
    [6. 에너지 퇴적], [잃어버린 에너지를 선량으로 퇴적], [E_dep = E_in - E_out],
    [7. 경계 검사], [셀을 떠났는지 확인], [예 → 버킷, 아니오 → 로컬 빈],
  ),
  caption: [순차 작업을 보여주는 물리 파이프라인],
)

=== 상세 작업 설명

1. *단계 제어*

   #tech-note(
     [단계 크기는 중요합니다: 너무 크면 부정확, 너무 작으면 느립니다. 2% 규칙은 좋은 절충안입니다. 또한 셀 경계를 확인하여 경계를 건너뛰지 않도록 합니다(버킷 시스템을 망가뜨릴 수 있음).]
   )

2. *에너지 손실*

   #plain-english[
     양성자가 물질을 통과할 때 원자를 이온화하여 에너지를 잃습니다. 에너지 손실률(dE/ds)은 "정지 능력"이라고 하며 NIST PSTAR 데이터베이스에서 가져옵니다.
   ]

3. *분산*

   #key-concept(
     [분산이 중요한 이유],
     [
       분산을 무시하면 깊이-선량 곡선이 너무 매끄러워집니다. 실제 세계에는 변동이 있습니다 - 일부 양성자는 많은 에너지를 잃고, 일부는 적게 잃습니다. 분산은 선량 분포에서 현실적인 "흐릿함"을 만듭니다.

       같은 경로에서도 일부 차량이 다른 차량보다 연비가 더 좋은 것과 같습니다.
     ]
   )

4. *MCS*

   #plain-english[
     양성자가 원자핵 근처를 지날 때마다 편향됩니다. 수백만 개의 상호작용을 통해 이것은 순각도 확산을 만듭니다. Highland 공식은 이 분포의 표준 편차를 예측합니다.
   ]

5. *핵 감쇠*

   #tech-note(
     [핵 반응은 드물지만 중요합니다. 양성자가 핵과 충돌하면 흡수되거나 빔 밖으로 산란될 수 있습니다. 이것을 지수衰减으로 모델링합니다: $W = W_0 e^(-sigma "ds")$. "손실된" 가중치는 핵 흡수 배열에서 추적됩니다.]
   )

6. *에너지 퇴적*

   #plain-english[
     양성자가 잃은 에너지는 사라지지 않습니다 - 조직에 선량으로 퇴적됩니다. 이것이 우리가 계산하려는 것입니다! 에너지 퇴적 단계는 모든 잃어버린 에너지를 합산하여 Edep 배열에 저장합니다.
   ]

7. *경계 검사*

   #key-concept(
     [셀 교차],
     [
       셀 경계를 교차하는 입자는 특별한 처리가 필요합니다. 이웃의 배열에 바로 쓸 수 없습니다(병렬에서 경합 조건을 일으킴). 대신 버킷에 수집하고 주요 수송 루프 후에 처리합니다.

       호텔 체크아웃을 한 후 다른 곳에 체크인하는 것과 같습니다.
     ]
   )

== 디렉토리 구조

#figure(
  table(
    columns: (3fr, 2fr),
    inset: 8pt,
    align: left,
    stroke: 1pt,
    table.header([*경로*], [*설명*]),
    // Root
    // src/core
    [ `grids.cpp`], [에너지/각도 그리드 - 입자를 위한 좌표계],
    [ `block_encoding.hpp`], [24비트 인코딩 - 에너지+각도를 하나의 숫자로 압축],
    [ `local_bins.hpp`], [4D 하위 셀 분할 - 블록당 512개 로컬 빈],
    [ `psi_storage.cpp`], [계층적 위상 공간 - 입자를 위한 희소 메모리],
    [ `buckets.cpp`], [버킷 방출 - 셀 간 입자 전송],
    // src/physics
    [ `highland.hpp`], [다중 쿨롬 산란 - 핵에서 튀는 입자],
    [ `energy_straggling.hpp`], [Vavilov 분산 - 에너지 변동],
    [ `nuclear.hpp`], [핵 감쇠 - 핵에 의해 흡수된 입자],
    [ `step_control.hpp`], [R 기반 단계 제어 - 적응형 단계 크기 조정],
    [ `fermi_eyges.hpp`], [횡방향 확산 이론 - 옆으로 퍼지는 빔],
    // src/lut
    [ `nist_loader.cpp`], [NIST PSTAR 데이터 - 실제 물리 측정],
    [ `r_lut.cpp`], [사거리-에너지 보간 - 양성자가 얼마나 멀리 가는지],
    // src/source
    [ `pencil_source.cpp`], [연필 빔 - 테스트를 위한 이상적인 0너비 빔],
    [ `gaussian_source.cpp`], [가우시안 빔 - 현실적인 유한 너비 빔],
    // src/boundary
    [ `boundaries.cpp`], [경계 유형 - 흡수/반사/주기적],
    [ `loss_tracking.cpp`], [손실 회계 - 입자가 어디로 가는지 추적],
    // src/audit
    [ `conservation.cpp`], [가중치/에너지 검사 - 물리 법칙 검증],
    [ `global_budget.cpp`], [전체 집계 - 누적 양 추적],
    [ `reporting.cpp`], [보고서 생성 - 출력 파일 만들기],
    // src/cuda/kernels
    [ `k1_activemask.cu`], [활성 셀 감지 - 입자가 있는 셀 찾기],
    [ `k2_coarsetransport.cu`], [고에너지 수송 - 빠름, 덜 정확함],
    [ `k3_finetransport.cu`], [정밀 수송 (메인) - 상세한 물리],
    [ `k4_transfer.cu`], [버킷 전송 - 셀 간 이동],
    [ `k5_audit.cu`], [보존 감사 - 물리 법칙 검사],
    [ `k6_swap.cu`], [버퍼 교환 - 다음 단계 준비],
    // src/utils
    [ `logger.cpp`], [로깅 시스템 - 무슨 일이 일어나는지 기록],
    [ `memory_tracker.cpp`], [GPU 메모리 추적 - 메모리 사용량 모니터링],
  ),
  caption: [설명이 포함된 완전한 디렉토리 구조],
)

== 핵심 설계 원칙

=== 1. 블록-희소 저장소

#plain-english[
  에너지, 각도 및 위치의 모든 가능한 조합을 저장하는 대부분(대부분 비어 있음) 대신 실제로 입자가 있는 블록만 저장합니다. 이것은 공책의 빈 페이지가 아니라 작성한 페이지만 저장하는 것과 같습니다.
]

#figure(
  table(
    columns: (1fr, 1fr, 1fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*저장소*], [*블록 수*], [*메모리*]),
    [조밀 저장소 (낭비)], [16,384개 (100%)], [33.6 MB],
    [희소 저장소 (효율적)], [2,304개 (14%)], [4.7 MB],
    table.footer([], [절감: 86%], [O(1) 조회: 해시 맵]),
  ),
  caption: [조밀 vs 희소 저장소 비교],
)

#key-concept(
  [메모리 효율성],
  [
    양성자 치료에서 위상 공간은 대부분 비어 있습니다. 주어진 에너지와 각도에서 입자는 공간의 작은 영역에만 존재합니다. 블록-희소 저장소는 이 희소성을 활용하여 메모리 사용량을 70-90% 감소시킵니다. 이것은 동일한 GPU로 더 큰 문제를 시뮬레이션할 수 있게 합니다.
  ]
)

=== 2. 계층적 세분화

#plain-english[
  우리는 다른 영역에서 다양한 수준의 세부정보를 사용합니다. 브래그 피크에서 멀리(고에너지)는 거친 수송을 사용합니다(빠름, 덜 정확함). 브래그 피크 근처(저에너지)는 정밀 수송을 사용합니다(느림, 더 정확함). 이것은 허용할 수 있는 곳에서 속도를 얻고 필요한 곳에서 정확도를 얻습니다.
]

#figure(
  table(
    columns: (1fr, 1fr, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
     table.header([영역], [방법], [이유]),
    [표면 근처], [거친 수송 (K2)], [고에너지 (>50 MeV), 큰 단계, 간단한 물리, 10× 더 빠름],
      [브래그 피크 근처], [정밀 수송 (K3)], [저에너지 (50 MeV 미만), 작은 단계, 전체 물리, 최대 정확도],
  ),
  caption: [계층적 수송 전략],
)

=== 3. GPU 우선 설계

#key-concept(
  [왜 GPU인가?],
  [
    최신 GPU는 CPU의 8-16개 코어 대비 수천 개 코어를 가집니다. 입자 수송과 같은 당연히 병렬 가능한 문제의 경우 GPU는 10-100배의 속도 향상을 제공합니다.

    *단점*: GPU 프로그래밍은 더 어렵습니다. 다음을 해야 합니다:
    - CPU와 GPU 간의 데이터 전송 최소화
    - 병렬 알고리즘 사용(순차 종속성 없음)
    - 메모리를 신중하게 관리(GPU 메모리는 제한됨)
   ]
)

#plain-english[
  우리의 설계는 GPU에 모든 것을 배치합니다. GPU에 데이터를 한 번 전송하고, 전체 시뮬레이션을 거기서 실행한 다음, 결과를 다시 전송합니다. 이것은 느린 CPU-GPU 전송을 최소화합니다.
]

#figure(
  table(
    columns: (auto, 2fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*구성요소*], [*특징*]),
    [CPU → GPU 전송], [느림 (10 GB/s), 구성 및 NIST LUT, 단일 전송],
    [GPU 계산], [빠름 (900 GB/s 메모리, 10 TFLOP), K1-K6 커널 실행],
    [GPU → CPU 전송], [느림 (10 GB/s), PsiC_out 및 EdepC, 단일 전송],
  ),
  caption: [CPU-GPU 데이터 흐름 - 전송 최소화가 핵심],
)

=== 4. 설계에 의한 보존

#plain-english[
  물리학에는 보존 법칙이 있습니다 - 에너지와 물질은 생성되거나 파괴될 수 없고 변형될 뿐입니다. 우리의 시뮬레이션은 모든 단계에서 보존을 확인하여 이 법칙을 강제합니다. 숫자가 맞지 않으면 버그가 있다는 것을 알 수 있습니다.
]

#figure(
  table(
    columns: (auto, 1fr, 1fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*양*], [*단계 전*], [*단계 후*]),
    [가중치], [W_in = 1.000], [W_out (0.950) + W_abs (0.050) = 1.000 ✓],
    [에너지], [E_in = 150.0 MeV], [E_out (140.0) + E_dep (10.0) = 150.0 MeV ✓],
  ),
  caption: [보존 검사 예제],
)

#key-concept(
  [보존이 중요한 이유],
  [
    시뮬레이션이 보존을 위반하면 버그가 있다는 것을 의미합니다. 에너지나 입자가 나타나거나 사라지는데 이것은 불가능합니다. 모든 단계에서 보존을 확인하면 끝에서 잘못된 결과를 얻는 대신 버그를 일찍 잡을 수 있습니다.

    통장 잔고를 조정하는 것과 같습니다 - 숫자가 맞지 않으면 오류가 있다는 것을 압니다.
   ]
)

=== 5. 모듈형 물리

#plain-english[
  각 물리적 과정은 자체 파일에 있습니다. 이것은 코드를 이해, 테스트 및 검증하기 쉽게 만듭니다. 산란 모델을 개선하려면 전체 코드베이스가 아니라 `highland.hpp`만 수정하면 됩니다.
]

#figure(
  table(
    columns: (auto, 1fr, 1fr),
    inset: 10pt,
    align: left,
    stroke: 1pt,
    table.header([*모듈*], [file], [*메서드*]),
    [Highland MCS], [`highland.hpp`], [`class Highland::scatter()`],
    [에너지 분산], [`energy_straggling.hpp`], [`class Vavilov::straggle()`],
    [핵 감쇠], [`nuclear.hpp`], [`class Nuclear::absorb()`],
    [단계 제어], [`step_control.hpp`], [`class StepCtrl::step()`],
    [Fermi-Eyges], [`fermi_eyges.hpp`], [`class FermiEyges::spread()`],
  ),
  caption: [모듈형 물리 아키텍처],
)

== 참고문헌

=== 데이터 소스

- NIST PSTAR 데이터베이스: #link("https://physics.nist.gov/PhysRefData/Star/Text/PSTAR.html")[https://physics.nist.gov/PhysRefData/Star/Text/PSTAR.html]
  - 다양한 물질에서 양성자의 정지 능력 및 사거리

- PDG 2024: #link("https://pdg.lbl.gov/")[https://pdg.lbl.gov/]
  - 입자 물리에 대한 입자 데이터 그룹 검토
  - 다중 쿨롬 산란에 대한 Highland 공식

- ICRU 보고서 73: 전자와 양전자에 대한 정지 능력
  - 에너지 손실 계산을 위한 기본 참조

=== 추가 읽기

- "The Physics of Proton Therapy" - Harald Paganetti
- "Monte Carlo Methods in Particle Transport" - Bielajew
- "CUDA C Programming Guide" - NVIDIA

---
#align(center)[*SM_2D 아키텍처 문서*]

#text(size: 9pt)[버전 2.0.0 - 확장판]
