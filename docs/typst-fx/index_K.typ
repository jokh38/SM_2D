#set text(font: "Linux Libertine", size: 11pt)
#set page(numbering: "1", margin: (left: 20mm, right: 20mm, top: 20mm, bottom: 20mm))
#set par(justify: true)
#set heading(numbering: "1.")

#show math.equation: set text(weight: "regular")

= SM_2D: 결정론적 양성자 수송 솔버

#align(center)[
  *완전한 코드 문서*

  _버전 1.0.0_
]

#align(left)[]
#figure(
  table(
    columns: 1fr,
    inset: 12pt,
    align: center,
    fill: rgb("#f0f8ff"),
    stroke: 0.5pt,
    [*SM_2D 개요*],
    table.header(
      [*목적:*], [양성자 치료 계획을 위한 방사선량 계산],
      [*방법:*], [결정론적 S-행렬 방법 (GPU 가속)],
      [*속도:*], [임상 사용 가능 (초 단위)],
      [*정확도:*], [측정 데이터와 1% 이내 오차],
    ),
  ),
  caption: [프로젝트 개요],
)

== SM_2D란 무엇인가?

#block(
  fill: rgb("#e0f0ff"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 이 코드가 하는 일

    *SM_2D*는 양성자 치료 중 방사선 에너지가 어디에 침적되는지 계산하는 컴퓨터 프로그램입니다. 의사들이 방사선 치료를 계획할 때 도움이 되는 매우 정확한 시뮬레이션이라고 생각하면 됩니다.

    === 핵심 비유

    물(양성자)을 스펀지(인체 조직)에 붓는 상상을 해보세요. 이 프로그램은 다음을 계산합니다:
    * 물이 얼마나 깊이 침투하는가
    * 물이 옆으로 얼마나 퍼지는가
    - 각 물방울이 정확히 어디에 떨어지는가

    "결정론적(deterministic)"이라는 말은 무작위 추측 대신 수학적 방정식을 사용한다는 뜻으로, 빠르고 정확합니다.
  ]
)

#block(
  fill: rgb("#fff2e6"),
  inset: 10pt,
  radius: 5pt,
  [
    === 핵심 개념: 왜 "결정론적"인가?

    두 가지 접근 방식이 있습니다:

    *몬테카를로 방법:* 주사위를 굴려서 무작위로 시뮬레이션
    - 장점: 구현이 쉬움
    - 단점: 천만 번 이상 시뮬레이션해야 정확해짐 (느림)

    *결정론적 방법 (SM_2D):* 수학 방정식으로 직접 계산
    - 장점: 빠름 (초 단위)
    - 단점: 구현이 어려움

    결정론적 방법은 복잡한 수학이 필요하지만, 임상에서 실시간으로 사용할 수 있을 만큼 빠릅니다.
  ]
)

== 초록

SM_2D는 방사선 치료 선량 계산을 위한 결정론적 양성자 수송 솔버입니다. 이 시스템은 임상 속도 계산을 위해 GPU 가속(CUDA)을 사용하며, 하일랜드 다중 쿨롱 산란, 바빌로프 에너지 분산, 핵 상호작용을 포함한 포괄적인 물리 모델과 함께 계층적 S-행렬 방법을 구현합니다.

---
#v(1em)

== C++ 개념 가이드 (비전문가를 위해)

#block(
  fill: rgb("#fff0cc"),
  inset: 10pt,
  radius: 5pt,
  [
    === 핵심 C++ 개념

    ==== "struct"란 무엇인가?

    *struct* (구조체)는 관련된 정보를 함께 담는 컨테이너입니다. 필드가 있는 양식 같은 것으로 생각하세요:

    *예시:* "Person" 구조체는 다음을 포함할 수 있습니다:
    - 이름 (텍스트)
    - 나이 (숫자)
    - 키 (숫자)

    이 코드에서 구조체는 에너지 값, 각도, 입자 위치 같은 것들을 담습니다.

    ==== "GPU 가속"이란 무엇인가?

    *GPU* (그래픽 처리 장치)는 보통 비디오 게임에 사용됩니다. 이 코드는 과학 계산을 위해 GPU를 재사용합니다:
    - GPU는 수천 개의 작은 프로세서를 가짐
    - 일반 CPU는 소수의 강력한 프로세서만 가짐
    - 복잡한 수학을 하나가 하는 대신, 1,000명이 단순한 수학을 하는 것과 같음

    ==== "커널"이란 무엇인가?

    CUDA 프로그래밍에서 *커널*은 GPU에서 실행되는 함수입니다. 문제의 작은 조각을 각자 처리하는 수천 명의 GPU 작업자에게 복사되는 작업이라고 생각하세요.

    ==== "위상 공간(phase space)"이란 무엇인가?

    *위상 공간*은 "입자의 가능한 모든 상태"라는 멋진 물리 용어입니다. 2D에서는 다음을 의미합니다:
    - 입자가 어디에 있는가? (x, z 위치)
    - 어느 방향으로 가는가? (각도 theta)
    - 얼마나 많은 에너지를 가지고 있는가? (E)
  ]
)

#v(1em)

=== 프로젝트 통계

#figure(
  table(
    columns: (auto, 1fr),
    inset: 8pt,
    align: left,
    table.header([*매개변수*], [*값*]),
    [언어], [C++17 with CUDA],
    [코드 라인 수], [~15,000],
    [GPU 메모리], [시뮬레이션당 ~4.3 GB],
    [정확도], [브래그 피크 1% 미만, 측면 확산 15% 미만],
    [컴퓨팅], [RTX 2080+ (Compute Capability 7.5+)],
  ),
  caption: [프로젝트 개요],
)

#v(1em)

=== 목차

#outline()

== 빠른 시작 가이드

=== SM_2D는 무엇을 구현하는가?

SM_2D는 다음을 구현합니다:

* 임상 속도 계산을 위한 GPU 가속 (CUDA)
* 결정론적 수송을 위한 계층적 S-행렬 방법
* 포괄적인 물리 (하일랜드 MCS, 바빌로프 분산, 핵 상호작용)
* 수치 정확도 검증을 위한 보존 감사

#block(
  fill: rgb("#e6fff2"),
  inset: 10pt,
  radius: 5pt,
  [
    === 왜 이것이 중요한가

    *속도:* 기존 몬테카를로 시뮬레이션은 몇 시간이 걸릴 수 있습니다. SM_2D는 몇 초가 걸립니다.

    *정확도:* 임상 사용 사례에서 측정 데이터와 1% 이내입니다.

    *검증:* 내장된 보존 검사가 수학이 올른지 확인합니다.
  ]
)

=== 디렉토리 구조

#figure(
  table(
    columns: (auto, 2fr),
    inset: 6pt,
    align: left,
    table.header([*디렉토리*], [*설명*]),
    [`run_simulation.cpp`], [메인 진입점],
    [`sim.ini`], [설정 파일],
    [`src/core/`], [데이터 구조 (격자, 저장소, 인코딩)],
    [`src/physics/`], [물리 모델 (MCS, 분산, 핵)],
    [`src/cuda/kernels/`], [CUDA 커널 (K1-K6 파이프라인)],
    [`src/lut/`], [NIST 데이터 및 거리-에너지 테이블],
    [`src/source/`], [빔 소스 (연필, 가우시안)],
    [`src/boundary/`], [경계 조건 및 손실 추적],
    [`src/audit/`], [보존 검사],
    [`src/validation/`], [물리 검증],
    [`src/utils/`], [로깅, 메모리 추적],
    [`tests/`], [단위 테스트 (GoogleTest)],
  ),
  caption: [디렉토리 구조],
)

#block(
  fill: rgb("#fff2e6"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 디렉토리 구조 이해하기

    *`src/core/`*: 집의 기초와 같음 - 데이터가 저장되는 방법 정의
    *`src/physics/`*: 입자 행동을 지배하는 물리 법칙
    *`src/cuda/kernels/`*: 실제 계산을 수행하는 GPU 프로그램
    *`src/audit/`*: 품질 관리 - 시뮬레이션이 올른지 확인

    이것은 자동차 공장과 비슷합니다:
    - core = 설계도
    - physics = 엔진 원리
    - cuda/kernels = 조립 로봇
    - audit = 품질 검사관
  ]
)

== 시스템 개요

=== CUDA 커널 파이프라인 흐름

시뮬레이션은 6단계 CUDA 커널 파이프라인을 구현합니다. 데이터가 어떻게 흐르는지 살펴보세요:

#figure(
  table(
    columns: (1fr, auto, 2fr),
    inset: 8pt,
    align: center,
    table.header([*단계*], [*커널*], [*무슨 일이 일어나는가*]),
    [1], [K1], [*식별* 어떤 셀이 자세한 물리가 필요한지 (낮은 에너지 입자)],
    [↓], [], [],
    [2], [K2 + K3], [*수송*: 조직을 통해 입자 이동
      - K2: 고에너지 입자용 빠른 방법
      - K3: 저에너지 입자용 자세한 방법],
    [↓], [], [],
    [3], [K4], [*전달*: 인접 셀 사이의 입자 이동],
    [↓], [], [],
    [4], [K5], [*검증*: 에너지/입자 손실이 없는지 확인],
    [↓], [], [],
    [5], [K6], [*교환*: 다음 단계를 위한 입/출력 버퍼 교환],
    [↻], [], [모든 입자가 멈추거나 퇴장할 때까지 반복],
  ),
  caption: [CUDA 커널 파이프라인 흐름],
)

#block(
  fill: rgb("#e6e6ff"),
  inset: 10pt,
  radius: 5pt,
  [
    === 핵심 개념: 왜 두 가지 수송 방법인가?

    *K2 (거친 것)*는 고속도로를 타는 것과 같습니다 - 빠르지만 덜 자세함. 크게 변하지 않는 고에너지 입자에 사용합니다.

    *K3 (미세한 것)*는 도시를 걷는 것과 같습니다 - 느리지만 자세함. 대부분의 방사선이 침적되는 "브래그 피크" 근처의 저에너지 입자에 사용합니다.

    이 이중 수준 접근 방식은 정확도를 유지하면서 시뮬레이션을 3-5배 더 빠르게 만듭니다.
  ]
)

=== 커널 요약

#figure(
  table(
    columns: (auto, 2fr),
    inset: 8pt,
    align: left,
    table.header([*커널*], [*목적*]),
    [K1: ActiveMask], [활성 셀 찾기 (E < 10 MeV)],
    [K2: CoarseTransport], [고에너지 입자용 빠른 수송 (E > 10 MeV)],
    [K3: FineTransport], [저에너지 입자용 완전한 물리 (브래그 피크 영역)],
    [K4: BucketTransfer], [셀 사이 입자 이동],
    [K5: ConservationAudit], [보존 법칙 검증],
    [K6: SwapBuffers], [다음 반복을 위한 입/출력 포인터 교환],
  ),
  caption: [CUDA 커널 파이프라인 요약],
)

=== 시각적 파이프라인 다이어그램

#figure(
  image("diagrams/cuda_pipeline_kr.svg", width: 100%),
  caption: [CUDA 파이프라인 시각화 - 입력에서 출력까지 전체 시뮬레이션 흐름],
)

== 핵심 개념 설명

=== 위상 공간 표현

#block(
  fill: rgb("#f2e6ff"),
  inset: 10pt,
  radius: 5pt,
  [
    === 핵심 개념: "위상 공간"이란 무엇인가?

    물리에서 *위상 공간*은 입자의 상태를 정의하는 모든 속성을 설명합니다. 조직 내 양성자의 경우:

    *위치:* 입자가 어디에 있는가? (x, z 좌표)
    *방향:* 어느 방향으로 가고 있는가? (theta 각도)
    *에너지:* 얼마나 많은 에너지를 가지고 있는가? (E)

    프로그램은 이 "공간"을 도서관을 선반으로 정리하는 것처럼 구획(bin)으로 나눕니다.
  ]
)

입자는 4차원 위상 공간으로 표현됩니다:

#figure(
  table(
    columns: (auto, 3fr),
    inset: 8pt,
    align: left,
    table.header([*차원*], [*설명*]),
    [$theta$ (각도)], [-90°에서 +90°까지 512개 구획 - 입자가 어느 방향으로 움직이는지 알려줌],
    [$E$ (에너지)], [0.1에서 250 MeV까지 256개 구획 (로그 간격) - 입자가 얼마나 많은 에너지를 가지는지 알려줌],
    [x_sub], [각 셀 내 4개 하위 구획 (횡방향 위치) - 셀 내 정확한 위치],
    [z_sub], [각 셀 내 4개 하위 구획 (깊이 위치) - 셀 내 정확한 위치],
  ),
  caption: [4차원 위상 공간 차원],
)

#figure(
  image("diagrams/phase_space_kr.svg", width: 90%),
  caption: [4차원 위상 공간과 블록 인코딩의 시각적 표현],
)

=== 구획(Bins) 이해하기

구획을 서류 캐비닛의 서랍 같다고 생각하세요:

#figure(
  table(
    columns: (auto, 3fr),
    inset: 8pt,
    align: left,
    table.header([*구획 번호*], [*에너지 레벨*]),
    [255], [250 MeV - 최고 에너지],
    [200], [200 MeV - 고에너지],
    [150], [100 MeV - 중간 에너지],
    [100], [50 MeV - 치료 범위],
    [50], [10 MeV - 브래그 피크 영역],
    [20], [1 MeV - 저에너지],
    [0], [0.1 MeV - 최소 에너지],
  ),
  caption: [에너지 구획 (로그 간격, 총 256개)],
)

#block(
  fill: rgb("#e6ffe6"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 왜 로그 간격인가?

    선형 간격 vs 로그 간격:

    *선형 간격:* 모든 에너지 구간이 동일한 너비
    - 문제: 저에너지에서 물리가 급격히 변하는데 놓침
    - 예: 0-1 MeV와 100-101 MeV가 같은 공간을 차지

    *로그 간격:* 낮은 에너지에서 더 많은 구획
    - 장점: 물리가 복잡한 곳에서 더 정확함
    - 예: 0-1 MeV는 100-101 MeV보다 10배 더 많은 구획

    브래그 피크 근처에서 정확도가 가장 중요하기 때문에 로그 간격을 사용합니다!
  ]
)

=== 블록-희소 저장소

```cpp
// 24비트 블록 ID = (b_E << 12) | b_theta
uint32_t block_id = encode_block(theta_bin, energy_bin);

// 블록당 분산 보존을 위한 512개 로컬 구획
uint16_t local_idx = encode_local_idx_4d(theta_local, E_local, x_sub, z_sub);
```

#block(
  fill: rgb("#f2f2f2"),
  inset: 10pt,
  radius: 5pt,
  [
    === 핵심 개념: 블록-희소 저장소

    *조밀(Dense) 저장:* 모든 가능한 조합이 메모리를 얻음 (낭비)
    *블록-희소(Block-sparse):* 실제로 존재하는 조합만 저장

    *비유:* 주차장 생각해보기
    - 조밀: 도시의 모든 자동차를 위해 공간 예약
    - 희소: 실제로 점유된 스팟만 추적

    결과: 70% 이상 메모리 절약!
  ]
)

=== 계층적 수송

#figure(
  table(
    columns: (auto, auto, 2fr),
    inset: 8pt,
    align: left,
    table.header([*에너지 범위*], [*수송 방법*], [*이유*]),
    [E > 10 MeV], [거친 것 (K2)], [빠른 계산, 물리가 천천히 변함],
    [E <= 10 MeV], [미세한 것 (K3)], [브래그 피크 정확도를 위한 자세한 물리],
  ),
  caption: [에너지별 수송 방법],
)

#figure(
  table(
    columns: 1fr,
    inset: 12pt,
    align: left,
    fill: rgb("#fffaf0"),
    stroke: 0.5pt,
    [*에너지 영역: 표면에서 최대 깊이까지*],
    [*표면 (0 mm)*],
    [├─ 고에너지 영역 (E > 10 MeV)],
    [│  → K2 (거친 것) 사용 - 빠른 계산],
    [│  → 입자가 직선으로 이동],
    [├─ 브래그 피크 영역 (E <= 10 MeV)],
    [│  → K3 (미세한 것) 사용 - 자세한 물리],
    [│  → 대부분의 에너지가 여기에 침적],
    [│  → 치료 계획에 중요],
    [*최대 깊이 (150 MeV의 경우 약 30 cm)*],
  ),
  caption: [에너지 영역 다이어그램],
)

#block(
  fill: rgb("#ffe6cc"),
  inset: 10pt,
  radius: 5pt,
  [
    === 왜 이것이 중요한가: 계층적 접근

    모든 입자에 자세한 물리를 사용하면:
    - 장점: 매우 정확함
    - 단점: 매우 느림 (임상 사용 불가)

    모든 입자에 빠른 물리를 사용하면:
    - 장점: 매우 빠름
    - 단점: 브래그 피크 근처에서 부정확함

    *계층적 접근 (SM_2D):*
    - 고에너지에서 빠른 방법 (물리가 단순함)
    - 저에너지에서 자세한 방법 (물리가 복잡함)
    - 결과: 빠르고 정확함!
  ]
)

== 물리 요약

=== 다중 쿨롱 산란 (하일랜드)

$ sigma_"theta" = (13.6 " MeV" / (beta c p)) times sqrt(x / X_0) times [1 + 0.038 times ln(x / X_0)] / sqrt(2) $

#block(
  fill: rgb("#d9e6ff"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 산란이란 무엇인가?

    *산란*은 양성자가 조직의 원자에서 튕겨 방향이 약간 바뀌는 것입니다.

    다음과 같이 생각하세요:
    - 안개 속을 통과하는 광자(빛 입자)는 모든 방향으로 산란됨
    - 조직을 통과하는 양성자도 산란되지만 훨씬 적음

    *하일랜드 공식*은 다음을 기반으로 얼마나 많은 산란이 발생하는지 예측합니다:
    - 양성자가 얼마나 멀리 이동하는지 (거리 = 산란 증가)
    - 어떤 재료를 통과하는지 (조직은 방사선 길이 X₀ = 360.8mm 보유)
    - 얼마나 빠르게 이동하는지 (더 빠름 = 덜 산란)
  ]
)

* X₀ (물): 360.8 mm - 이것은 물의 "방사선 길이"입니다
* 2D 보정: $1 / sqrt(2)$ - 2D 시뮬레이션을 위한 3D 물리 보정

=== 에너지 분산 (바빌로프)

$ kappa = xi / T_"max"$를 기반으로 세 가지 영역:

#figure(
  table(
    columns: (auto, auto, 2fr),
    inset: 8pt,
    align: left,
    table.header([*κ (카파)*], [*영역*], [*설명*]),
    [κ > 10], [보어 (가우시안)], [많은 작은 에너지 손실 - 종 곡선 분포],
    [0.01 < κ < 10], [바빌로프], [중간 경우 - 복잡한 분포],
    [κ < 0.01], [란다우], [적은 큰 에너지 손실 - 비대칭 분포],
  ),
  caption: [에너지 분산 영역],
)

#block(
  fill: rgb("#ffe6e6"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 분산이란 무엇인가?

    *분산(straggling)*은 "에너지 손실의 불확실성"을 의미합니다.

    주사위를 굴리는 것으로 생각하세요:
    - 보어 영역: 많은 주사위 굴리기 - 평균이 예측 가능함 (가우시안)
    - 란다우 영역: 주사위 하나 굴리기 - 결과가 예측 불가능함 (비대칭)

    양성자는 각 단계에서 정확히 같은 양의 에너지를 잃지 않습니다. 분산은 이 무작위성을 모델링합니다.
  ]
)

#block(
  fill: rgb("#f2e6ff"),
  inset: 10pt,
  radius: 5pt,
  [
    === 핵심 개념: 세 가지 영역 이해하기

    $kappa$는 "많은 작은 충돌"과 "적은 큰 충돌"의 비율을 알려줍니다:

    *보어 (κ > 10):* 수천 개의 작은 충돌
    - 종 곡선 (종 모양)으로 에너지 손실 분포
    - 중심 극한 정리 작동
    - 계산 쉬움

    *바빌로프 (0.01 < κ < 10):* 혼합
    - 수학적으로 복잡함
    - 특수 함수 필요
    - SM_2D는 여기서 정확함!

    *란다우 (κ < 0.01):* 적은 큰 충돌
    - 긴 꼬리 비대칭 분포
    - "원뿔" 에너지 손실 이벤트 지배
  ]
)

=== 핵 감쇠

$ W times exp(-sigma(E) times dif s) $

#block(
  fill: rgb("#e6ffe6"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 핵 상호작용

    때때로 양성자는 원자핵과 충돌하여 빔에서 흡수되거나 산란됩니다.

    다음과 같이 생각하세요:
    - 대부분의 양성자는 조직을 통과함 (계속)
    - 일부는 핵과 충돌함 (빔에서 제거됨)
    - 이것은 드물지만 정확도에 중요함

    공식은 다음을 계산합니다: "이 단계에서 생존할 확률은 얼마인가?"
  ]
)

에너지 종속 단면 ICRU 63.

=== 단계 제어 (R 기반)

$ dif s = min(0.02 times R, 1 " mm", "cell_size") $

안정성을 위해 정지 전력 대신 거리-에너지 LUT를 사용합니다.

#block(
  fill: rgb("#ffe6cc"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 단계 제어

    시뮬레이션은 입자 경로를 작은 "단계"로 나눕니다. 문제는 각 단계가 얼마나 커야 하는가입니다.

    *너무 큼:* 부정확한 물리
    *너무 작음:* 느린 시뮬레이션

    *해결책:* 입자의 남은 *거리* (아직 얼마나 더 이동할 수 있는지) 사용
    - 고에너지 (긴 거리): 더 큰 단계
    - 저에너지 (짧은 거리): 더 작은 단계
    - 이것은 자동으로 물리에 적응합니다!
  ]
)

== 메모리 레이아웃

#figure(
  table(
    columns: (auto, auto, auto),
    inset: 8pt,
    align: left,
    table.header([*버퍼*], [*크기*], [*목적*]),
    [PsiC_in/out], [각각 1.1 GB], [위상 공간 저장소 - 입자 데이터가 있는 곳],
    [EdepC], [0.5 GB], [에너지 침적 - 선량 계산 결과],
     [AbsorbedWeight], [0.5 GB], [차단/핵 추적 - 품질 관리],
    [AbsorbedEnergy], [0.25 GB], [핵 에너지 예산 - 보존 추적],
    [BoundaryLoss], [0.1 GB], [경계 손실 - 시뮬레이션을 떠나는 입자],
    [ActiveMask/List], [0.5 GB], [활성 셀 추적 - 최적화],
  ),
  caption: [GPU 메모리 레이아웃],
)

#text(size: 10pt)[*총계: ~4.3 GB GPU 메모리*]

#figure(
  image("diagrams/memory_layout_kr.svg", width: 90%),
  caption: [GPU 메모리 레이아웃 시각화],
)

#block(
  fill: rgb("#f2f2f2"),
  inset: 10pt,
  radius: 5pt,
  [
    === 왜 이렇게 많은 메모리가 필요한가?

    시뮬레이션을 수천 개의 공간 셀을 통해 수백만 개의 입자를 추적하는 것으로 생각하세요.

    각 입자는 다음이 필요합니다:
    - 위치 (위치)
    - 방향 (진행 방향)
    - 에너지 (얼마나 많은 에너지)
    - 얼마나 많은 "무게" (확률)를 가지고 있는지

    4.3 GB로 약 1억 3,100만 개의 입자 상태를 추적할 수 있습니다!
  ]
)

== 정확도 목표

#figure(
  table(
    columns: (auto, auto, auto),
    inset: 8pt,
    align: left,
    table.header([*관측 가능*], [*목표*], [*중요한 이유*]),
    [브래그 피크 위치], [±2%], [중요: 치료 선량이 전달되는 위치 결정],
    [측면 시그마 (중간 범위)], [±15%], [중요: 빔 폭 정확도 영향],
    [측면 시그마 (브래그)], [±20%], [중요: 반음영 (빔 가장자리) 영향],
    [무게 보존], [$\< 10^-6$], [품질 관리: 입자가 사라지지 않음 확인],
    [에너지 보존], [$\< 10^-5$], [품질 관리: 에너지가 계산되었는지 확인],
  ),
  caption: [검증 목표 및 임상적 중요성],
)

모든 목표: 통과

#block(
  fill: rgb("#ffe6cc"),
  inset: 10pt,
  radius: 5pt,
  [
    === 왜 이것이 중요한가: 임상적 정확도

    암 치료에서 정확도는 생명을 구합니다:

    *브래그 피크 위치 ±2%:*
    - 브래그 피크가 2% 어디에 있든 암을 치료함
    - 2% 틀리면 건강한 조직을 손상시킬 수 있음
    - SM_2D는 $\< 1%$ 오차로 목표를 초과 달성!

    *무게 보존 $\< 10^-6$:*
    - 백만 입자 중 하나만 손실되어도 심각함
    - 보존 법칙 위반은 물리 버그를 의미
    - SM_2D는 품질 보증을 위해 이를 자동으로 확인!
  ]
)

== 핵심 클래스

#figure(
  table(
    columns: (auto, auto, 2fr),
    inset: 8pt,
    align: left,
    table.header([*클래스*], [*모듈*], [*목적*]),
    [EnergyGrid], [core], [로그 간격 에너지 구획 - 에너지를 256개 레벨로 나눔],
    [AngularGrid], [core], [균일 각도 구획 - 방향을 512개 각도로 나눔],
    [PsiC], [core], [계층적 위상 공간 저장소 - 주요 데이터 구조],
    [RLUT], [lut], [거리-에너지 보간법 - 에너지와 거리 사이 변환],
    [PencilSource], [source], [결정론적 빔 소스 - 이상적인 빔],
    [GaussianSource], [source], [확률론적 빔 소스 - 현실적인 빔],
    [GlobalAudit], [audit], [보존 추적 - 품질 관리],
    [BraggPeakResult], [validation], [피크 분석 - 검증 결과],
  ),
  caption: [핵심 클래스 및 목적],
)

#block(
  fill: rgb("#d9e6ff"),
  inset: 10pt,
  radius: 5pt,
  [
    === 쉽게 설명하기: 클래스란 무엇인가?

    객체 지향 프로그래밍에서 *클래스*는 데이터와 기능을 함께 그룹화하는 청사진입니다.

    *비유:* 붕어빵 틀
    - 클래스 = 틀 (설계도)
    - 객체 = 붕어빵 (실제 인스턴스)

    *예시:* `EnergyGrid` 클래스
    - 데이터: 256개 에너지 구획
    - 기능: 에너지를 구획 인덱스로 변환
    - 이점: 코드 재사용성 및 조직화
  ]
)

== 추가 읽기

#link("architecture.typ")[아키텍처 개요] - 다이어그램이 포함된 완전한 시스템 설계
#link("physics.typ")[물리 모델] - 공식이 포함된 완전한 물리 참조
#link("data_structures.typ")[데이터 구조] - 저장소 및 인코딩 세부 정보
#link("cuda_pipeline.typ")[CUDA 파이프라인] - 자세한 커널 문서
#link("api.typ")[API 참조] - 함수별 문서

== 용어 사전

#block(
  fill: rgb("#faf5e6"),
  inset: 10pt,
  radius: 5pt,
  [
    === 기술 용어 사전

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*브래그 피크 (Bragg Peak)*] - 양성자가 대부분의 에너지를 침적하는 지점, 윌리엄 브래그의 이름을 따서 명명됨. 암 치료에 중요함.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*CSDA 거리 (CSDA Range)*] - "연속 감속 근사법" - 입자가 멈추기 전에 얼마나 멀리 이동하는지.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*결정론적 (Deterministic)*] - 무작위 표본 추출(몬테카를로) 대신 방정식 사용.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*위상 공간 (Phase Space)*] - 입자의 가능한 모든 상태를 설명하는 수학적 공간.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*분산 (Straggling)*] - 에너지 손실의 통계적 변동.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*MCS*] - 다중 쿨롱 산란 - 원자에서 튕기는 양성자.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*LUT*] - 조회 테이블 - 미리 계산된 값을 저장한 테이블.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*커널 (Kernel)*] - GPU에서 실행되는 함수.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*구획 (Bin)*] - 데이터를 정리하는 컨테이너 (도서관 선반 같음).

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*감쇠 (Attenuation)*] - 입자 빔이 재료를 통과할 때 감소.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*단면 (Cross-section)*] - 핵 상호작용이 일어날 확률.

    =#block(stroke: 0.5pt, inset: 5pt, radius: 3pt)[*반음영 (Penumbra)*] - 방사선 빔의 가장자리 영역.
  ]
)

== 참고문헌

#figure(
  table(
    columns: (auto, 2fr),
    inset: 8pt,
    align: left,
    table.header([*출처*], [*주제*]),
    [NIST PSTAR], [양성자용 정지력 및 거리],
    [PDG 2024], [산란용 하일랜드 공식],
    [ICRU 63], [양성자용 핵 단면],
    [Vavilov 1957], [에너지 분산 이론],
  ),
  caption: [참고문헌],
)

---
#align(center)[
  *SM_2D 양성자 치료 수송 솔버용 생성*

  #text(size: 9pt)[MIT 라이선스 - 버전 1.0.0]
]
